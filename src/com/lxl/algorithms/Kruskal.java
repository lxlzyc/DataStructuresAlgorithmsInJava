package com.lxl.algorithms;

/**
 * *Prim算法和Kruskal算法都能从连通图找出最小生成树。区别在于Prim算法是挨个找，而Kruskal是先排序再找。
 * Prim算法实现的是找出一个有权重连通图中的最小生成树，即：具有最小权重且连接到所有结点的树。(强调的是树，树是没有回路的)。
 * 
 * Kruskal算法与Prim算法的不同之处在于，Kruskal在找最小生成树结点之前，需要对所有权重边做从小到大排序。
 * 将排序好的权重边依次加入到最小生成树中，如果加入时产生回路就跳过这条边，加入下一条边。 当所有结点都加入到最小生成树中之后，就找出了最小生成树。
 * 克鲁斯卡尔算法需要对图的边进行访问，所以克鲁斯卡尔算法的时间复杂度只和边又关系，可以证明其时间复杂度为O（eloge）。 算法过程：
 * 
 * 1.将图各边按照权值进行排序
 * 
 * 2.将图遍历一次，找出权值最小的边，（条件：此次找出的边不能和已加入最小生成树集合的边构成环），若符合条件，
 * 则加入最小生成树的集合中。不符合条件则继续遍历图，寻找下一个最小权值的边。
 * 
 * 3.递归重复步骤1，直到找出n-1条边为止（设图有n个结点，则最小生成树的边数应为n-1条），算法结束。得到的就是此图的最小生成树。
 * 
 * 
 * 克鲁斯卡尔（Kruskal）算法因为只与边相关，则适合求稀疏图的最小生成树。而prime算法因为只与顶点有关，所以适合求稠密图的最小生成树。
 * 
 * 
 * 无疑，Kruskal算法在效率上要比Prim算法快，因为Kruskal只需要对权重边做一次排序，而Prim算法则需要做多次排序。
 * 尽管Prim算法每次做的算法涉及的权重边不一定会涵盖连通图中的所有边，但是随着所使用的排序算法的效率的提高，
 * Kruskal算法和Prim算法之间的差异将会清晰的显性出来。
 * 
 * 
 */
public class Kruskal {

}
